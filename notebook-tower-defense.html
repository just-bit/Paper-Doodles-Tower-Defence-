<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notebook Defense ‚Äî Tower Defense</title>
	<link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rajdhani:wght@300;500;700&display=swap"
		rel="stylesheet">
	<style>
		@font-face {
			font-family: 'Solena';
			src: url('Solena.woff2') format('woff2');
			font-weight: normal;
			font-style: normal;
		}

		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		:root {
			--blue: #0000ff;
			--ink-blue: #1a4a7a;
			--ink-red: #c23a3a;
			--ink-green: #2a7a4a;
			--ink-orange: #d4762c;
			--ink-purple: #6a3a9a;
			--paper-bg: #ffffff;
			--paper-lines: #b4d2f0;
			--panel-bg: rgba(255, 255, 255, 0.95);
		}

		body {
			background-image: url(01.jpeg);
			background-size: cover;
			background-position: center;
			background-repeat: no-repeat;
			min-height: 100vh;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			font-family: 'Solena', cursive;
			color: #333;
			overflow: hidden;
		}

		.game-container {
			display: flex;
			gap: 20px;
			padding: 20px;
			max-width: 1400px;
		}

		.main-area {
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		.stats-title {
			font-family: 'Solena', cursive;
			font-size: 40px;
			font-weight: 400;
			color: #0000ff;
			letter-spacing: 4px;
			text-shadow: 1px 1px 0 rgba(0, 0, 0, 0.1);
			transform: rotate(-1deg);
			text-align: center;
			margin-bottom: 10px;
		}

		.stats-row {
			display: flex;
			justify-content: space-around;
		}

		.stats-bar {
			display: flex;
			flex-direction: column;
			padding: 15px 25px;
			width: 600px;
			box-sizing: border-box;
			background: var(--paper-bg);
			background-image: linear-gradient(rgba(140, 180, 220, 0.3) 1px, transparent 1px),
				linear-gradient(90deg, rgba(140, 180, 220, 0.3) 1px, transparent 1px);
			background-size: 16px 16px;
			border: none;
			border-radius: 2px;
			box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.15),
				4px 4px 15px rgba(0, 0, 0, 0.1);
			position: relative;
		}

		.stats-bar::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 2px;
			right: -2px;
			bottom: -2px;
			background: linear-gradient(to bottom, #f0f0f0, #e0e0e0);
			z-index: -1;
			border-radius: 2px;
		}

		.stat {
			display: flex;
			gap: 10px;
			font-size: 1.2rem;
			font-weight: 500;
		}

		.stat-icon {
			width: 30px;
			height: 30px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.3rem;
		}

		.stat-value {
			font-weight: 700;
			font-size: 2rem;
			text-align: center;
		}

		.stat.gold .stat-value {
			color: #0000ff;
		}

		.stat.lives .stat-value {
			color: #0000ff;
		}

		.stat.wave .stat-value {
			color: #0000ff;
		}

		.stat.score .stat-value {
			color: #0000ff;
		}

		#gameCanvas {
			border: none;
			border-radius: 1px;
			box-shadow: 4px 4px 12px rgba(0, 0, 0, 0),
				8px 8px 25px rgba(0, 0, 0, 0.15);
			cursor: crosshair;
			background: var(--paper-bg);
			position: relative;
			z-index: 5;
		}

		.canvas-wrapper {
			position: relative;
			display: flex;
			align-items: center;
		}

		/* –°—Ç–æ–ø–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü –ø–æ–¥ –æ—Å–Ω–æ–≤–Ω—ã–º –ª–∏—Å—Ç–æ–º */
		.page-stack {
			position: absolute;
			left: 2px;
			top: 3px;
			width: 600px;
			height: 700px;
			z-index: 1;
		}

		.page-stack::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 2px;
			right: -2px;
			bottom: -2px;
			background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
			border-radius: 1px;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
		}

		.page-stack::after {
			content: '';
			position: absolute;
			top: 4px;
			left: 4px;
			right: -4px;
			bottom: -4px;
			background: linear-gradient(to bottom, #f0f0f0, #e0e0e0);
			border-radius: 1px;
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
			z-index: -1;
		}

		.page-edge {
			position: absolute;
			top: 6px;
			left: 6px;
			right: -6px;
			bottom: -6px;
			background: linear-gradient(to bottom, #eaeaea, #d8d8d8);
			border-radius: 1px;
			z-index: -2;
		}

		.page-edge-2 {
			position: absolute;
			top: 8px;
			left: 8px;
			right: -8px;
			bottom: -8px;
			background: linear-gradient(to bottom, #e5e5e5, #d0d0d0);
			border-radius: 1px;
			z-index: -3;
			box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.15);
		}

		.side-panel {
			width: 220px;
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		.panel {
			background: var(--paper-bg);
			background-image: linear-gradient(rgba(140, 180, 220, 0.3) 1px, transparent 1px),
				linear-gradient(90deg, rgba(140, 180, 220, 0.3) 1px, transparent 1px);
			background-size: 16px 16px;
			border: none;
			border-radius: 2px;
			padding: 20px;
			box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.15),
				4px 4px 15px rgba(0, 0, 0, 0.1);
			position: relative;
		}

		.panel::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 2px;
			right: -2px;
			bottom: -2px;
			background: linear-gradient(to bottom, #f0f0f0, #e0e0e0);
			z-index: -1;
			border-radius: 2px;
		}

		.panel-title {
			font-family: 'Solena', cursive;
			font-size: 40px;
			font-weight: 500;
			color: var(--blue);
			margin-bottom: 5px;
			padding-bottom: 10px;
			letter-spacing: 3px !important
		}

		.tower-btn {
			width: 100%;
			padding: 12px;
			margin-bottom: 8px;
			background: transparent;
			border: 2px solid transparent;
			border-radius: 3px;
			cursor: pointer;
			text-align: left;
			letter-spacing: 2px !important;
		}

		.tower-btn.selected {
			border: 2px solid var(--blue);
			background: transparent;
		}

		.tower-btn.tower1 {
			color: var(--ink-red);
		}

		.tower-btn.tower2 {
			color: var(--ink-red);
		}

		.tower-btn.tower3 {
			color: var(--ink-red);
		}

		.tower-name {
			font-family: 'Solena', cursive;
			font-size: 32px;
			font-weight: 700;
			margin-bottom: 5px;
		}

		.tower-stats {
			font-family: 'Solena', cursive;
			font-size: 25px;
			line-height: 1;
			color: var(--blue);
			font-weight: 700;
		}

		.tower-cost {
			font-family: 'Solena', cursive;
			color: var(--blue);
			font-size: 25px;
			margin-top: 5px;
			font-weight: 700;
		}

		.control-btn {
			width: 100%;
			padding: 10px;
			font-family: 'Solena', cursive;
			font-size: 25px;
			font-weight: 700;
			border: 2px solid var(--blue);
			border-radius: 0;
			color: var(--blue);
			cursor: pointer;
			transition: all 0.3s ease;
			letter-spacing: 1px;
			background-color: transparent;
		}

		.control-btn:has(+ .control-btn) {
			margin-top: 30px;
		}

		.control-btn+.control-btn {
			margin-top: 10px;
		}

		.control-btn.paused {
			background-color: rgba(0, 0, 255, 0.1);
		}

		.control-btn.sell-active {
			background-color: rgba(194, 58, 58, 0.2);
			border-color: var(--ink-red);
			color: var(--ink-red);
		}

		.enemy-info {
			font-size: 0.8rem;
			line-height: 1.6;
		}

		.enemy-type {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 8px;
			padding: 8px;
			background: rgba(255, 255, 255, 0.5);
			border-radius: 5px;
			border-left: 3px solid;
		}

		.enemy-dot {
			width: 12px;
			height: 12px;
			border-radius: 50%;
		}

		.enemy-dot.basic {
			background: var(--ink-red);
			border-color: var(--ink-red);
		}

		.enemy-dot.fast {
			background: var(--ink-orange);
			border-color: var(--ink-orange);
		}

		.enemy-dot.tank {
			background: var(--ink-purple);
			border-color: var(--ink-purple);
		}

		.enemy-dot.boss {
			background: #d4326c;
			border-color: #d4326c;
		}

		.enemy-type:nth-child(1) {
			border-left-color: var(--ink-red);
		}

		.enemy-type:nth-child(2) {
			border-left-color: var(--ink-orange);
		}

		.enemy-type:nth-child(3) {
			border-left-color: var(--ink-purple);
		}

		.enemy-type:nth-child(4) {
			border-left-color: #d4326c;
		}

		.hotkey {
			display: inline-block;
			background: rgba(0, 0, 0, 0.1);
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 0.7rem;
			margin-left: 5px;
			font-family: 'Rajdhani', sans-serif;
			border: 1px solid #ccc;
		}

		.game-over-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(245, 245, 220, 0.95);
			display: none;
			align-items: center;
			justify-content: center;
			flex-direction: column;
			gap: 30px;
			z-index: 100;
			animation: fadeIn 0.5s ease;
		}

		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		.game-over-overlay.show {
			display: flex;
		}

		.game-over-text {
			font-family: 'Solena', cursive;
			font-size: 28px;
			font-weight: 400;
			transform: rotate(-3deg);
		}

		.final-score {
			font-family: 'Solena', cursive;
			font-size: 20px;
			color: var(--blue);
		}

		.instructions {
			font-size: 0.75rem;
			opacity: 0.6;
			text-align: center;
			margin-top: 10px;
			line-height: 1.5;
			color: #666;
		}

		/* Pause overlay */
		.pause-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 600px;
			height: 700px;
			background: rgba(255, 255, 255, 0.7);
			display: none;
			align-items: center;
			justify-content: center;
			z-index: 10;
			pointer-events: none;
		}

		.pause-overlay.show {
			display: flex;
		}

		.pause-text {
			font-family: 'Solena', cursive;
			font-size: 60px;
			color: var(--blue);
			transform: rotate(-5deg);
			text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.1);
		}

		/* Paper Doodles title - torn paper effect */
		.paper-title {
			position: fixed;
			top: 15px;
			left: 15px;
			padding: 18px 30px 22px 22px;
			background: var(--paper-bg);
			background-image: linear-gradient(rgba(140, 180, 220, 0.3) 1px, transparent 1px),
				linear-gradient(90deg, rgba(140, 180, 220, 0.3) 1px, transparent 1px);
			background-size: 16px 16px;
			font-family: 'Solena', cursive;
			font-size: 42px;
			color: var(--blue);
			transform: rotate(-3deg);
			z-index: 50;
			box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.2),
				1px 1px 3px rgba(0, 0, 0, 0.1);
			/* Torn edges + cut corner for curl effect */
			clip-path: polygon(0% 2%, 5% 0%, 12% 1%, 25% 0%, 38% 2%, 52% 0%, 65% 1%, 78% 0%, 88% 2%, 95% 0%, 100% 1%, 102.5% 69.24%, 89.57% 94.13%, 72.00% 97.07%, 58% 99%, 45% 100%, 32% 98%, 18% 100%, 8% 99%, 0% 100%);
		}

		/* Curled corner - simple triangle fold */
		.paper-title::before {
			content: '';
			position: absolute;
			bottom: 0;
			right: 0;
			width: 25px;
			height: 25px;
			background: linear-gradient(135deg, transparent 50%, #e8e5e0 50%, #d8d5d0 100%);
			box-shadow:
				-2px -2px 3px rgba(0, 0, 0, 0.15),
				-4px -4px 6px rgba(0, 0, 0, 0.08);
		}

		/* Shadow under the curl on the table */
		.paper-title::after {
			content: '';
			position: absolute;
			bottom: -3px;
			right: 5px;
			width: 20px;
			height: 8px;
			background: rgba(0, 0, 0, 0.2);
			filter: blur(4px);
			border-radius: 50%;
		}
	</style>
</head>

<body>
	<!-- Paper Doodles title -->
	<div class="paper-title">Paper Doodles</div>

	<div class="game-container">
		<div class="main-area">

			<div class="stats-bar">
				<div class="stats-title">Tower Defense</div>
				<div class="stats-row">
					<div class="stat gold">
						<!--					<div class="stat-icon">üí∞</div>-->
						<div>
							<div
								style="font-size: 26px;color: #0000ff;font-weight: 700;letter-spacing: 2px !important;">
								Gold</div>
							<div class="stat-value" id="gold">150</div>
						</div>
					</div>
					<div class="stat lives">
						<!--					<div class="stat-icon">‚ù§Ô∏è</div>-->
						<div>
							<div
								style="font-size: 26px;color: #0000ff;font-weight: 700;letter-spacing: 2px !important;">
								Life</div>
							<div class="stat-value" id="lives">5</div>
						</div>
					</div>
					<div class="stat wave">
						<!--					<div class="stat-icon">üåä</div>-->
						<div>
							<div
								style="font-size: 26px; color: #0000ff;font-weight: 700;letter-spacing: 2px !important;">
								Wave</div>
							<div class="stat-value" id="wave">1</div>
						</div>
					</div>
					<div class="stat score">
						<!--					<div class="stat-icon">‚≠ê</div>-->
						<div>
							<div
								style="font-size: 26px;color: #0000ff;font-weight: 700;letter-spacing: 2px !important;">
								Score</div>
							<div class="stat-value" id="score">0</div>
						</div>
					</div>
				</div>
			</div>

			<div class="canvas-wrapper">
				<!-- –°—Ç–æ–ø–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü -->
				<div class="page-stack">
					<div class="page-edge"></div>
					<div class="page-edge-2"></div>
				</div>

				<canvas id="gameCanvas" width="600" height="700"></canvas>

				<!-- Pause overlay -->
				<div class="pause-overlay" id="pauseOverlay">
					<div class="pause-text">PAUSED</div>
				</div>
			</div>

			<div class="instructions">
				Click map ‚Äî place tower | Click tower ‚Äî upgrade | 1-3 ‚Äî select tower | Space ‚Äî start wave | P ‚Äî pause |
				S ‚Äî sell
			</div>
		</div>

		<div class="side-panel">
			<div class="panel">
				<div class="panel-title">Towers</div>

				<button class="tower-btn tower1 selected" data-tower="tower1">
					<div class="tower-name">Tower-1</div>
					<div class="tower-stats">Buy: 80</div>
					<div class="tower-cost">Upgrade: 120</div>
				</button>

				<button class="tower-btn tower2" data-tower="tower2">
					<div class="tower-name">Tower-2</div>
					<div class="tower-stats">Buy: 150</div>
					<div class="tower-cost">Upgrade: 200</div>
				</button>

				<button class="tower-btn tower3" data-tower="tower3">
					<div class="tower-name">Tower-3</div>
					<div class="tower-stats">Buy: 250</div>
					<div class="tower-cost">Upgrade: 350</div>
				</button>
				<button class="control-btn" id="startWave">Start</button>
				<button class="control-btn" id="pauseBtn">Pause</button>
				<button class="control-btn" id="sellBtn">Sell Mode</button>
				<button class="control-btn danger" id="restart">Restart</button>
			</div>
		</div>
	</div>

	<div class="game-over-overlay" id="gameOver">
		<div class="game-over-text">GAME OVER</div>
		<div class="final-score">Final Score: <span id="finalScore">0</span></div>
		<button class="control-btn" onclick="location.reload()">Play Again</button>
	</div>

	<script>
		const canvas = document.getElementById('gameCanvas');
		const ctx = canvas.getContext('2d');

		// Game state
		let gold = 420;
		let lives = 5;
		let wave = 0;
		let score = 0;
		let selectedTower = 'tower1';
		let waveInProgress = false;
		let gameOver = false;
		let isPaused = false;
		let lastPauseTime = 0;
		let totalPausedTime = 0;
		let sellMode = false;

		// Tower types - based on cell count
		const towerTypes = {
			tower1: { cost: 80, upgradeCost: 120, damage: 20, range: 90, fireRate: 600, cells: 1, name: 'Tower 1' },
			tower2: { cost: 150, upgradeCost: 200, damage: 15, range: 130, fireRate: 500, cells: 2, name: 'Tower 2' },
			tower3: { cost: 250, upgradeCost: 350, damage: 25, range: 180, fireRate: 550, cells: 3, name: 'Tower 3' }
		};

		// Enemy definitions
		const enemyTypes = {
			basic: { hp: 150, speed: 2.2, reward: 6, color: '#c23a3a', size: 10 },
			fast: { hp: 80, speed: 4.5, reward: 8, color: '#d4762c', size: 8 },
			tank: { hp: 500, speed: 1.5, reward: 20, color: '#6a3a9a', size: 14 },
			boss: { hp: 1000, speed: 1.2, reward: 50, color: '#d4326c', size: 20 }
		};

		// Path waypoints - adjusted for vertical A5 format
		const path = [
			{ x: 40, y: 80 },
			{ x: 150, y: 80 },
			{ x: 150, y: 200 },
			{ x: 480, y: 200 },
			{ x: 480, y: 320 },
			{ x: 150, y: 320 },
			{ x: 150, y: 440 },
			{ x: 480, y: 440 },
			{ x: 480, y: 560 },
			{ x: 300, y: 560 },
			{ x: 300, y: 660 }
		];

		// Game objects
		let towers = [];
		let enemies = [];
		let projectiles = [];
		let particles = [];

		// Grid for tower placement
		const gridSize = 40;
		const grid = [];
		for (let x = 0; x < canvas.width / gridSize; x++) {
			grid[x] = [];
			for (let y = 0; y < canvas.height / gridSize; y++) {
				grid[x][y] = { occupied: false, isPath: false };
			}
		}

		// Mark path cells and nearby cells
		function markPathCells() {
			// First mark the path itself
			for (let i = 0; i < path.length - 1; i++) {
				const start = path[i];
				const end = path[i + 1];
				const steps = Math.max(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) / 10;

				for (let j = 0; j <= steps; j++) {
					const t = j / steps;
					const x = Math.floor((start.x + (end.x - start.x) * t) / gridSize);
					const y = Math.floor((start.y + (end.y - start.y) * t) / gridSize);
					if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) {
						grid[x][y].isPath = true;
					}
				}
			}

			// Then mark cells adjacent to path as nearPath
			for (let x = 0; x < grid.length; x++) {
				for (let y = 0; y < grid[0].length; y++) {
					if (grid[x][y].isPath) {
						// Mark all 8 neighbors as nearPath
						for (let dx = -1; dx <= 1; dx++) {
							for (let dy = -1; dy <= 1; dy++) {
								const nx = x + dx;
								const ny = y + dy;
								if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length) {
									if (!grid[nx][ny].isPath) {
										grid[nx][ny].nearPath = true;
									}
								}
							}
						}
					}
				}
			}
		}

		markPathCells();

		// Toggle pause
		function togglePause() {
			if (gameOver) return;

			isPaused = !isPaused;
			const pauseBtn = document.getElementById('pauseBtn');
			const pauseOverlay = document.getElementById('pauseOverlay');

			if (isPaused) {
				lastPauseTime = performance.now();
				pauseBtn.textContent = 'Resume';
				pauseBtn.classList.add('paused');
				pauseOverlay.classList.add('show');
			} else {
				totalPausedTime += performance.now() - lastPauseTime;
				pauseBtn.textContent = 'Pause';
				pauseBtn.classList.remove('paused');
				pauseOverlay.classList.remove('show');
				requestAnimationFrame(gameLoop);
			}
		}

		// Toggle sell mode
		function toggleSellMode() {
			sellMode = !sellMode;
			const sellBtn = document.getElementById('sellBtn');

			if (sellMode) {
				sellBtn.textContent = 'Cancel Sell';
				sellBtn.classList.add('sell-active');
				canvas.style.cursor = 'not-allowed';
			} else {
				sellBtn.textContent = 'Sell Mode';
				sellBtn.classList.remove('sell-active');
				canvas.style.cursor = 'crosshair';
			}
		}

		// Tower class - multi-cell with individual upgrades and shooting
		class Tower {
			constructor(x, y, type) {
				this.x = x;
				this.y = y;
				this.type = type;
				const stats = towerTypes[type];
				this.cellCount = stats.cells;
				this.upgradeCost = stats.upgradeCost;

				this.baseDamage = stats.damage;
				this.baseRange = stats.range;
				this.baseFireRate = stats.fireRate;

				// Each cell has its own data: level, lastFire, position
				this.cells = [];
				const cellSize = 14;
				const spacing = cellSize + 2;
				const totalWidth = this.cellCount * cellSize + (this.cellCount - 1) * 2;
				const startX = this.x - totalWidth / 2 + cellSize / 2;

				for (let i = 0; i < this.cellCount; i++) {
					this.cells.push({
						level: 1,
						lastFire: 0,
						x: startX + i * spacing,
						y: this.y,
						target: null
					});
				}

				this.showRange = false;
			}

			// Get range based on average cell level
			get range() {
				const avgLevel = this.cells.reduce((sum, c) => sum + c.level, 0) / this.cellCount;
				return this.baseRange * (1 + (avgLevel - 1) * 0.1);
			}

			// Get fire rate for a specific cell based on its level
			getCellFireRate(cellIndex) {
				const level = this.cells[cellIndex].level;
				return this.baseFireRate * Math.pow(0.9, level - 1);
			}

			// Get damage for a specific cell based on its level
			getCellDamage(cellIndex) {
				const level = this.cells[cellIndex].level;
				return this.baseDamage * (1 + (level - 1) * 0.5);
			}

			// Upgrade specific cell
			upgradeCell(cellIndex) {
				if (cellIndex < 0 || cellIndex >= this.cellCount) return false;
				if (this.cells[cellIndex].level >= 3) return false;
				if (gold < this.upgradeCost) return false;

				gold -= this.upgradeCost;
				this.cells[cellIndex].level++;
				updateUI();
				return true;
			}

			// Check if click is on a specific cell and return its index
			getCellAtPosition(clickX, clickY) {
				const cellSize = 14;
				const halfSize = cellSize / 2 + 4; // –¥–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∫–ª–∏–∫–∞

				for (let i = 0; i < this.cells.length; i++) {
					const cell = this.cells[i];
					if (Math.abs(clickX - cell.x) < halfSize && Math.abs(clickY - cell.y) < halfSize) {
						return i;
					}
				}
				return -1;
			}

			getUpgradeCost() {
				return this.upgradeCost;
			}

			// Calculate sell value (50% of total investment)
			getSellValue() {
				const baseCost = towerTypes[this.type].cost;
				let totalUpgradeCost = 0;

				// Calculate upgrade costs for each cell
				for (const cell of this.cells) {
					// Each level above 1 costs upgradeCost
					totalUpgradeCost += (cell.level - 1) * this.upgradeCost;
				}

				const totalInvestment = baseCost + totalUpgradeCost;
				return Math.floor(totalInvestment * 0.5);
			}

			// Find target for a specific cell
			findTargetForCell(cellIndex) {
				const cell = this.cells[cellIndex];
				let closest = null;
				let closestDist = this.range;

				for (const enemy of enemies) {
					const dist = Math.hypot(enemy.x - cell.x, enemy.y - cell.y);
					if (dist < closestDist) {
						closest = enemy;
						closestDist = dist;
					}
				}
				return closest;
			}

			update(time) {
				// Each cell independently finds target and fires
				for (let i = 0; i < this.cells.length; i++) {
					const cell = this.cells[i];
					cell.target = this.findTargetForCell(i);

					if (cell.target) {
						const fireRate = this.getCellFireRate(i);
						if (time - cell.lastFire > fireRate) {
							this.fireFromCell(i);
							cell.lastFire = time;
						}
					}
				}
			}

			fireFromCell(cellIndex) {
				const cell = this.cells[cellIndex];
				if (!cell.target) return;

				projectiles.push(new Projectile(
					cell.x, cell.y,
					cell.target,
					this.getCellDamage(cellIndex),
					'#cc2222',
					this.type
				));
			}

			draw() {
				const cellSize = 14;
				const half = cellSize / 2;
				const color = '#cc2222';

				ctx.strokeStyle = color;
				ctx.lineWidth = 1.5;
				ctx.lineCap = 'round';
				ctx.lineJoin = 'round';

				// Draw each cell
				for (let i = 0; i < this.cells.length; i++) {
					const cell = this.cells[i];
					const cellX = cell.x;
					const cellY = cell.y;
					const level = cell.level;

					// Pre-computed wobble for this cell (stable)
					const seed = cellX * 100 + cellY + i * 50;
					const w1 = Math.sin(seed * 0.1) * 1;
					const w2 = Math.cos(seed * 0.2) * 1;
					const w3 = Math.sin(seed * 0.3) * 1;
					const w4 = Math.cos(seed * 0.4) * 1;

					// Draw square (hand-drawn wobbly)
					ctx.strokeStyle = color;
					ctx.beginPath();
					ctx.moveTo(cellX - half + w1, cellY - half + w2);
					ctx.lineTo(cellX + half + w2, cellY - half + w3);
					ctx.lineTo(cellX + half + w3, cellY + half + w4);
					ctx.lineTo(cellX - half + w4, cellY + half + w1);
					ctx.closePath();
					ctx.stroke();

					// Draw X inside
					const inset = 2;
					ctx.beginPath();
					ctx.moveTo(cellX - half + inset + w2, cellY - half + inset + w1);
					ctx.lineTo(cellX + half - inset + w4, cellY + half - inset + w3);
					ctx.stroke();

					ctx.beginPath();
					ctx.moveTo(cellX + half - inset + w3, cellY - half + inset + w2);
					ctx.lineTo(cellX - half + inset + w1, cellY + half - inset + w4);
					ctx.stroke();

					// Level indicators - dots above each cell
					const dotSpacing = 4;
					const totalDotsWidth = (level - 1) * dotSpacing;
					const dotStartX = cellX - totalDotsWidth / 2;
					for (let j = 0; j < level; j++) {
						ctx.beginPath();
						ctx.arc(dotStartX + j * dotSpacing, cellY - half - 4, 1.5, 0, Math.PI * 2);
						ctx.fillStyle = color;
						ctx.fill();
					}
				}

				// Range indicator on hover/selection
				if (this.showRange) {
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
					ctx.strokeStyle = sellMode ? '#c23a3a' : '#0000ff';
					ctx.lineWidth = 1;
					ctx.setLineDash([8, 4]);
					ctx.stroke();
					ctx.setLineDash([]);

					// Show sell value in sell mode
					if (sellMode) {
						const sellValue = this.getSellValue();
						ctx.font = '16px Solena, cursive';
						ctx.fillStyle = '#2a7a4a';
						ctx.textAlign = 'center';
						ctx.fillText('+' + sellValue + ' gold', this.x, this.y - 25);
					}
				}
			}
		}

		// Projectile class
		class Projectile {
			constructor(x, y, target, damage, color, type) {
				this.x = x;
				this.y = y;
				this.target = target;
				this.damage = damage;
				this.color = color;
				this.type = type;
				this.speed = 8;
				this.size = 5;
			}

			update() {
				if (!this.target || this.target.hp <= 0) {
					return false;
				}

				const dx = this.target.x - this.x;
				const dy = this.target.y - this.y;
				const dist = Math.hypot(dx, dy);

				if (dist < 10) {
					this.hit();
					return false;
				}

				this.x += (dx / dist) * this.speed;
				this.y += (dy / dist) * this.speed;
				return true;
			}

			hit() {
				// Simple damage to target
				this.target.takeDamage(this.damage);

				// Hit particles
				for (let i = 0; i < 5; i++) {
					particles.push(new Particle(this.x, this.y, this.color, 'hit'));
				}
			}

			draw() {
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				ctx.fillStyle = this.color;
				ctx.fill();

				// Trail - ink streak
				ctx.beginPath();
				ctx.moveTo(this.x, this.y);
				const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
				ctx.lineTo(this.x - Math.cos(angle) * 12, this.y - Math.sin(angle) * 12);
				ctx.strokeStyle = this.color + '88';
				ctx.lineWidth = 2;
				ctx.stroke();
			}
		}

		// Enemy class
		class Enemy {
			constructor(type) {
				const stats = enemyTypes[type];
				this.type = type;
				this.hp = stats.hp;
				this.maxHp = stats.hp;
				this.speed = stats.speed;
				this.baseSpeed = stats.speed;
				this.reward = stats.reward;
				this.color = stats.color;
				this.size = stats.size;
				this.pathIndex = 0;
				this.x = path[0].x;
				this.y = path[0].y;
				this.slowTimer = 0;
				this.slowAmount = 1;
			}

			update() {
				if (this.pathIndex >= path.length - 1) {
					lives--;
					updateUI();
					if (lives <= 0) {
						endGame();
					}
					return false;
				}

				// Slow effect
				if (this.slowTimer > 0) {
					this.slowTimer--;
					this.speed = this.baseSpeed * this.slowAmount;
				} else {
					this.speed = this.baseSpeed;
				}

				const target = path[this.pathIndex + 1];
				const dx = target.x - this.x;
				const dy = target.y - this.y;
				const dist = Math.hypot(dx, dy);

				if (dist < this.speed) {
					this.pathIndex++;
				} else {
					this.x += (dx / dist) * this.speed;
					this.y += (dy / dist) * this.speed;
				}

				return this.hp > 0;
			}

			takeDamage(amount) {
				this.hp -= amount;
				if (this.hp <= 0) {
					gold += this.reward;
					score += this.reward * 10;
					updateUI();
					// Death particles
					for (let i = 0; i < 10; i++) {
						particles.push(new Particle(this.x, this.y, this.color, 'death'));
					}
				}
			}

			draw() {
				// Body - hand drawn circle
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
				ctx.fillStyle = this.color;
				ctx.fill();
				ctx.strokeStyle = this.color;
				ctx.lineWidth = 2;
				ctx.stroke();

				// Inner detail
				ctx.beginPath();
				ctx.arc(this.x - 2, this.y - 2, this.size * 0.3, 0, Math.PI * 2);
				ctx.fillStyle = 'rgba(255,255,255,0.4)';
				ctx.fill();

				// HP bar - notebook style
				const hpPercent = this.hp / this.maxHp;
				const barWidth = this.size * 2.5;
				const barHeight = 4;

				ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
				ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 12, barWidth, barHeight);
				ctx.strokeStyle = '#999';
				ctx.lineWidth = 1;
				ctx.strokeRect(this.x - barWidth / 2, this.y - this.size - 12, barWidth, barHeight);

				const hpColor = hpPercent > 0.5 ? '#2a7a4a' : hpPercent > 0.25 ? '#d4762c' : '#c23a3a';
				ctx.fillStyle = hpColor;
				ctx.fillRect(this.x - barWidth / 2 + 1, this.y - this.size - 11, (barWidth - 2) * hpPercent, barHeight - 2);

				// Slow indicator - blue swirl
				if (this.slowTimer > 0) {
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.size + 5, 0, Math.PI * 2);
					ctx.strokeStyle = '#1a4a7a66';
					ctx.lineWidth = 2;
					ctx.setLineDash([3, 3]);
					ctx.stroke();
					ctx.setLineDash([]);
				}
			}
		}

		// Particle class
		class Particle {
			constructor(x, y, color, type) {
				this.x = x;
				this.y = y;
				this.color = color;
				this.type = type;
				this.life = 1;
				this.decay = type === 'explosion' ? 0.03 : 0.05;
				const angle = Math.random() * Math.PI * 2;
				const speed = type === 'explosion' ? Math.random() * 5 + 2 : Math.random() * 3 + 1;
				this.vx = Math.cos(angle) * speed;
				this.vy = Math.sin(angle) * speed;
				this.size = type === 'explosion' ? Math.random() * 4 + 2 : Math.random() * 3 + 1;
			}

			update() {
				this.x += this.vx;
				this.y += this.vy;
				this.life -= this.decay;
				this.vx *= 0.95;
				this.vy *= 0.95;
				return this.life > 0;
			}

			draw() {
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
				ctx.fillStyle = this.color + Math.floor(this.life * 255).toString(16).padStart(2, '0');
				ctx.fill();
			}
		}

		// Generate offset path with intermediate points for hand-drawn effect
		function generateOffsetPathDetailed(originalPath, offset) {
			const result = [];

			for (let i = 0; i < originalPath.length; i++) {
				const curr = originalPath[i];
				let perpX, perpY;

				if (i === 0) {
					const next = originalPath[1];
					const dist = Math.hypot(next.x - curr.x, next.y - curr.y);
					perpX = -(next.y - curr.y) / dist;
					perpY = (next.x - curr.x) / dist;
				} else if (i === originalPath.length - 1) {
					const prev = originalPath[i - 1];
					const dist = Math.hypot(curr.x - prev.x, curr.y - prev.y);
					perpX = -(curr.y - prev.y) / dist;
					perpY = (curr.x - prev.x) / dist;
				} else {
					const prev = originalPath[i - 1];
					const next = originalPath[i + 1];

					const d1 = Math.hypot(curr.x - prev.x, curr.y - prev.y);
					const d2 = Math.hypot(next.x - curr.x, next.y - curr.y);

					const p1x = -(curr.y - prev.y) / d1;
					const p1y = (curr.x - prev.x) / d1;
					const p2x = -(next.y - curr.y) / d2;
					const p2y = (next.x - curr.x) / d2;

					perpX = (p1x + p2x) / 2;
					perpY = (p1y + p2y) / 2;
					const len = Math.hypot(perpX, perpY);
					if (len > 0) {
						perpX /= len;
						perpY /= len;
					}
				}

				result.push({
					x: curr.x + perpX * offset,
					y: curr.y + perpY * offset,
					isCorner: i > 0 && i < originalPath.length - 1
				});

				// Add intermediate points between corners for wobble
				if (i < originalPath.length - 1) {
					const next = originalPath[i + 1];
					const dist = Math.hypot(next.x - curr.x, next.y - curr.y);
					const segments = Math.floor(dist / 40); // One point every 40px

					let nextPerpX, nextPerpY;
					if (i + 1 === originalPath.length - 1) {
						nextPerpX = perpX;
						nextPerpY = perpY;
					} else {
						const nextNext = originalPath[i + 2];
						const d1 = Math.hypot(next.x - curr.x, next.y - curr.y);
						const d2 = Math.hypot(nextNext.x - next.x, nextNext.y - next.y);
						const p1x = -(next.y - curr.y) / d1;
						const p1y = (next.x - curr.x) / d1;
						const p2x = -(nextNext.y - next.y) / d2;
						const p2y = (nextNext.x - next.x) / d2;
						nextPerpX = (p1x + p2x) / 2;
						nextPerpY = (p1y + p2y) / 2;
						const len = Math.hypot(nextPerpX, nextPerpY);
						if (len > 0) {
							nextPerpX /= len;
							nextPerpY /= len;
						}
					}

					for (let j = 1; j <= segments; j++) {
						const t = j / (segments + 1);
						const midX = curr.x + (next.x - curr.x) * t;
						const midY = curr.y + (next.y - curr.y) * t;
						const midPerpX = perpX + (nextPerpX - perpX) * t;
						const midPerpY = perpY + (nextPerpY - perpY) * t;

						result.push({
							x: midX + midPerpX * offset,
							y: midY + midPerpY * offset,
							isCorner: false
						});
					}
				}
			}
			return result;
		}

		// Two parallel lines forming the path edges
		const pathWidth = 18;
		const leftPath = generateOffsetPathDetailed(path, -pathWidth);
		const rightPath = generateOffsetPathDetailed(path, pathWidth);

		// Pre-generate random offsets for hand-drawn effect (stable, not every frame)
		const leftWobble = leftPath.map((p, i) => {
			const wobbleAmount = p.isCorner ? 1 : 1.5;
			return {
				x: (Math.sin(i * 3.7 + 0.5) * wobbleAmount) + (Math.cos(i * 7.1) * wobbleAmount * 0.3),
				y: (Math.cos(i * 4.3 + 0.3) * wobbleAmount) + (Math.sin(i * 5.9) * wobbleAmount * 0.3)
			};
		});
		const rightWobble = rightPath.map((p, i) => {
			const wobbleAmount = p.isCorner ? 1 : 1.5;
			return {
				x: (Math.sin(i * 2.9 + 1.2) * wobbleAmount) + (Math.cos(i * 6.3) * wobbleAmount * 0.3),
				y: (Math.cos(i * 3.1 + 0.8) * wobbleAmount) + (Math.sin(i * 4.7) * wobbleAmount * 0.3)
			};
		});

		// Draw a path with rounded corners at corner points only, lineTo for others
		function drawRoundedPathWithWobble(points, wobble, radius) {
			if (points.length < 2) return;

			ctx.beginPath();
			ctx.moveTo(points[0].x + wobble[0].x, points[0].y + wobble[0].y);

			for (let i = 1; i < points.length - 1; i++) {
				const curr = points[i];
				const next = points[i + 1];
				const w = wobble[i];
				const wNext = wobble[i + 1];

				if (curr.isCorner) {
					// Use arcTo for corners
					ctx.arcTo(
						curr.x + w.x,
						curr.y + w.y,
						next.x + wNext.x,
						next.y + wNext.y,
						radius
					);
				} else {
					// Use lineTo for regular points
					ctx.lineTo(curr.x + w.x, curr.y + w.y);
				}
			}

			const last = points.length - 1;
			ctx.lineTo(points[last].x + wobble[last].x, points[last].y + wobble[last].y);
		}

		// Draw cave at the start of the path (enemy spawn point)
		function drawCave() {
			const caveX = path[0].x;
			const caveY = path[0].y;

			ctx.strokeStyle = '#2255cc';
			ctx.lineWidth = 2;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			const w = (seed) => Math.sin(seed * 0.7) * 0.8;

			// Rounded cave opening
			const caveW = 48;
			const caveH = 38;

			// Cave arch (rounded top)
			ctx.beginPath();
			ctx.moveTo(caveX - caveW / 2 - 3 + w(1), caveY + 18 + w(2));
			ctx.lineTo(caveX - caveW / 2 + w(3), caveY + w(4));
			ctx.quadraticCurveTo(
				caveX - caveW / 2 + 5 + w(5), caveY - caveH + 10 + w(6),
				caveX + w(7), caveY - caveH + w(8)
			);
			ctx.quadraticCurveTo(
				caveX + caveW / 2 - 5 + w(9), caveY - caveH + 10 + w(10),
				caveX + caveW / 2 + w(11), caveY + w(12)
			);
			ctx.lineTo(caveX + caveW / 2 + 3 + w(13), caveY + 18 + w(14));
			ctx.stroke();

			// Top fangs hanging down
			ctx.beginPath();
			ctx.moveTo(caveX - 14 + w(20), caveY - caveH + 12 + w(21));
			ctx.lineTo(caveX - 10 + w(22), caveY - caveH + 28 + w(23));
			ctx.lineTo(caveX - 6 + w(24), caveY - caveH + 14 + w(25));
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(caveX + 6 + w(26), caveY - caveH + 14 + w(27));
			ctx.lineTo(caveX + 10 + w(28), caveY - caveH + 28 + w(29));
			ctx.lineTo(caveX + 14 + w(30), caveY - caveH + 12 + w(31));
			ctx.stroke();

			// Bottom fangs pointing up
			ctx.beginPath();
			ctx.moveTo(caveX - 10 + w(40), caveY + 16 + w(41));
			ctx.lineTo(caveX - 6 + w(42), caveY + w(43));
			ctx.lineTo(caveX - 2 + w(44), caveY + 14 + w(45));
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(caveX + 2 + w(46), caveY + 14 + w(47));
			ctx.lineTo(caveX + 6 + w(48), caveY + w(49));
			ctx.lineTo(caveX + 10 + w(50), caveY + 16 + w(51));
			ctx.stroke();

		}

		// Draw epic castle at the end of the path (player base to defend)
		function drawCastle() {
			const castleX = path[path.length - 1].x;
			const castleY = path[path.length - 1].y + 20;

			ctx.strokeStyle = '#2255cc';
			ctx.lineWidth = 2;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			// Subtle wobble for hand-drawn effect
			const w = (seed) => Math.sin(seed * 0.7) * 0.8;

			// Castle dimensions
			const baseWidth = 80;
			const baseHeight = 35;
			const baseLeft = castleX - baseWidth / 2;
			const baseBottom = castleY;
			const baseTop = baseBottom - baseHeight;

			// Main wall (closed rectangle)
			ctx.beginPath();
			ctx.moveTo(baseLeft + w(1), baseBottom + w(2));
			ctx.lineTo(baseLeft + w(3), baseTop + w(4));
			ctx.lineTo(baseLeft + baseWidth + w(5), baseTop + w(6));
			ctx.lineTo(baseLeft + baseWidth + w(7), baseBottom + w(8));
			ctx.closePath();
			ctx.stroke();

			// Crenellations on main wall
			const crenelW = 6;
			const crenelH = 8;
			for (let i = 0; i < 7; i++) {
				const cx = baseLeft + 8 + i * 10;
				ctx.beginPath();
				ctx.moveTo(cx + w(10 + i), baseTop + w(11 + i));
				ctx.lineTo(cx + w(12 + i), baseTop - crenelH + w(13 + i));
				ctx.lineTo(cx + crenelW + w(14 + i), baseTop - crenelH + w(15 + i));
				ctx.lineTo(cx + crenelW + w(16 + i), baseTop + w(17 + i));
				ctx.stroke();
			}

			// LEFT TOWER
			const towerW = 20;
			const towerH = 45;
			const leftTowerX = baseLeft - 5;
			const leftTowerTop = baseBottom - towerH;

			ctx.beginPath();
			ctx.moveTo(leftTowerX + w(20), baseBottom + w(21));
			ctx.lineTo(leftTowerX + w(22), leftTowerTop + w(23));
			ctx.lineTo(leftTowerX + towerW + w(24), leftTowerTop + w(25));
			ctx.lineTo(leftTowerX + towerW + w(26), baseBottom + w(27));
			ctx.stroke();

			// Left tower crenellations
			for (let i = 0; i < 2; i++) {
				const cx = leftTowerX + 3 + i * 9;
				ctx.beginPath();
				ctx.moveTo(cx + w(30 + i), leftTowerTop + w(31 + i));
				ctx.lineTo(cx + w(32 + i), leftTowerTop - 7 + w(33 + i));
				ctx.lineTo(cx + 6 + w(34 + i), leftTowerTop - 7 + w(35 + i));
				ctx.lineTo(cx + 6 + w(36 + i), leftTowerTop + w(37 + i));
				ctx.stroke();
			}

			// Left tower roof
			ctx.beginPath();
			ctx.moveTo(leftTowerX - 3 + w(40), leftTowerTop - 7 + w(41));
			ctx.lineTo(leftTowerX + towerW / 2 + w(42), leftTowerTop - 28 + w(43));
			ctx.lineTo(leftTowerX + towerW + 3 + w(44), leftTowerTop - 7 + w(45));
			ctx.stroke();

			// LEFT TOWER window
			ctx.beginPath();
			ctx.arc(leftTowerX + towerW / 2 + w(46) * 0.3, leftTowerTop + 18 + w(47) * 0.3, 4, 0, Math.PI * 2);
			ctx.stroke();

			// RIGHT TOWER
			const rightTowerX = baseLeft + baseWidth - towerW + 5;

			ctx.beginPath();
			ctx.moveTo(rightTowerX + w(50), baseBottom + w(51));
			ctx.lineTo(rightTowerX + w(52), leftTowerTop + w(53));
			ctx.lineTo(rightTowerX + towerW + w(54), leftTowerTop + w(55));
			ctx.lineTo(rightTowerX + towerW + w(56), baseBottom + w(57));
			ctx.stroke();

			// Right tower crenellations
			for (let i = 0; i < 2; i++) {
				const cx = rightTowerX + 3 + i * 9;
				ctx.beginPath();
				ctx.moveTo(cx + w(60 + i), leftTowerTop + w(61 + i));
				ctx.lineTo(cx + w(62 + i), leftTowerTop - 7 + w(63 + i));
				ctx.lineTo(cx + 6 + w(64 + i), leftTowerTop - 7 + w(65 + i));
				ctx.lineTo(cx + 6 + w(66 + i), leftTowerTop + w(67 + i));
				ctx.stroke();
			}

			// Right tower roof
			ctx.beginPath();
			ctx.moveTo(rightTowerX - 3 + w(70), leftTowerTop - 7 + w(71));
			ctx.lineTo(rightTowerX + towerW / 2 + w(72), leftTowerTop - 28 + w(73));
			ctx.lineTo(rightTowerX + towerW + 3 + w(74), leftTowerTop - 7 + w(75));
			ctx.stroke();

			// RIGHT TOWER window
			ctx.beginPath();
			ctx.arc(rightTowerX + towerW / 2 + w(76) * 0.3, leftTowerTop + 18 + w(77) * 0.3, 4, 0, Math.PI * 2);
			ctx.stroke();

			// CENTER TOWER (tallest)
			const centerW = 26;
			const centerH = 60;
			const centerX = castleX - centerW / 2;
			const centerTop = baseBottom - centerH;

			ctx.beginPath();
			ctx.moveTo(centerX + w(80), baseTop + w(81));
			ctx.lineTo(centerX + w(82), centerTop + w(83));
			ctx.lineTo(centerX + centerW + w(84), centerTop + w(85));
			ctx.lineTo(centerX + centerW + w(86), baseTop + w(87));
			ctx.stroke();

			// Center tower crenellations
			for (let i = 0; i < 3; i++) {
				const cx = centerX + 2 + i * 8;
				ctx.beginPath();
				ctx.moveTo(cx + w(90 + i), centerTop + w(91 + i));
				ctx.lineTo(cx + w(92 + i), centerTop - 8 + w(93 + i));
				ctx.lineTo(cx + 6 + w(94 + i), centerTop - 8 + w(95 + i));
				ctx.lineTo(cx + 6 + w(96 + i), centerTop + w(97 + i));
				ctx.stroke();
			}

			// Center tower roof (tallest)
			ctx.beginPath();
			ctx.moveTo(centerX - 4 + w(100), centerTop - 8 + w(101));
			ctx.lineTo(centerX + centerW / 2 + w(102), centerTop - 35 + w(103));
			ctx.lineTo(centerX + centerW + 4 + w(104), centerTop - 8 + w(105));
			ctx.stroke();

			// Center tower windows
			ctx.beginPath();
			ctx.arc(centerX + centerW / 2 + w(106) * 0.3, centerTop + 15 + w(107) * 0.3, 4, 0, Math.PI * 2);
			ctx.stroke();
			ctx.beginPath();
			ctx.arc(centerX + centerW / 2 + w(108) * 0.3, centerTop + 30 + w(109) * 0.3, 4, 0, Math.PI * 2);
			ctx.stroke();

			// Gate (arched door)
			const gateW = 18;
			const gateH = 22;
			const gateX = castleX;
			const gateY = baseBottom;

			ctx.beginPath();
			ctx.moveTo(gateX - gateW / 2 + w(110), gateY + w(111));
			ctx.lineTo(gateX - gateW / 2 + w(112), gateY - gateH + 9 + w(113));
			ctx.arc(gateX, gateY - gateH + 9, gateW / 2, Math.PI, 0, false);
			ctx.lineTo(gateX + gateW / 2 + w(114), gateY + w(115));
			ctx.stroke();

			// Gate bars
			ctx.lineWidth = 1.5;
			for (let i = 0; i < 3; i++) {
				const bx = gateX - 5 + i * 5;
				ctx.beginPath();
				ctx.moveTo(bx + w(116 + i), gateY - gateH + 12 + w(117 + i));
				ctx.lineTo(bx + w(118 + i), gateY + w(119 + i));
				ctx.stroke();
			}
			ctx.lineWidth = 2;

			// Flags on towers
			// Center flag (main)
			const flagX = centerX + centerW / 2;
			const flagY = centerTop - 35;
			ctx.beginPath();
			ctx.moveTo(flagX + w(120), flagY + w(121));
			ctx.lineTo(flagX + w(122), flagY - 18 + w(123));
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(flagX + w(124), flagY - 18 + w(125));
			ctx.quadraticCurveTo(flagX + 8 + w(126), flagY - 14 + w(127), flagX + 14 + w(128), flagY - 16 + w(129));
			ctx.quadraticCurveTo(flagX + 8 + w(130), flagY - 10 + w(131), flagX + w(132), flagY - 8 + w(133));
			ctx.stroke();

			// Left tower flag
			const lfX = leftTowerX + towerW / 2;
			const lfY = leftTowerTop - 28;
			ctx.beginPath();
			ctx.moveTo(lfX + w(140), lfY + w(141));
			ctx.lineTo(lfX + w(142), lfY - 14 + w(143));
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(lfX + w(144), lfY - 14 + w(145));
			ctx.quadraticCurveTo(lfX + 6 + w(146), lfY - 11 + w(147), lfX + 11 + w(148), lfY - 13 + w(149));
			ctx.quadraticCurveTo(lfX + 6 + w(150), lfY - 8 + w(151), lfX + w(152), lfY - 6 + w(153));
			ctx.stroke();

			// Right tower flag
			const rfX = rightTowerX + towerW / 2;
			ctx.beginPath();
			ctx.moveTo(rfX + w(160), lfY + w(161));
			ctx.lineTo(rfX + w(162), lfY - 14 + w(163));
			ctx.stroke();
			ctx.beginPath();
			ctx.moveTo(rfX + w(164), lfY - 14 + w(165));
			ctx.quadraticCurveTo(rfX + 6 + w(166), lfY - 11 + w(167), rfX + 11 + w(168), lfY - 13 + w(169));
			ctx.quadraticCurveTo(rfX + 6 + w(170), lfY - 8 + w(171), rfX + w(172), lfY - 6 + w(173));
			ctx.stroke();
		}

		// Draw path - two parallel blue pen lines with rounded corners and hand-drawn effect
		function drawPath() {
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			const cornerRadius = 15;

			// Left edge line
			drawRoundedPathWithWobble(leftPath, leftWobble, cornerRadius);
			ctx.strokeStyle = '#2255cc';
			ctx.lineWidth = 2;
			ctx.stroke();

			// Left edge - second stroke for pen effect
			drawRoundedPathWithWobble(leftPath, leftWobble.map(w => ({ x: w.x + 0.5, y: w.y + 0.5 })), cornerRadius);
			ctx.strokeStyle = 'rgba(34, 85, 204, 0.3)';
			ctx.lineWidth = 1.5;
			ctx.stroke();

			// Right edge line
			drawRoundedPathWithWobble(rightPath, rightWobble, cornerRadius);
			ctx.strokeStyle = '#2255cc';
			ctx.lineWidth = 2;
			ctx.stroke();

			// Right edge - second stroke for pen effect
			drawRoundedPathWithWobble(rightPath, rightWobble.map(w => ({ x: w.x + 0.5, y: w.y + 0.5 })), cornerRadius);
			ctx.strokeStyle = 'rgba(34, 85, 204, 0.3)';
			ctx.lineWidth = 1.5;
			ctx.stroke();
		}

		// Draw grid - notebook paper style
		function drawGrid() {
			const smallGrid = 16; // Small visual grid for notebook look

			// Horizontal blue lines
			ctx.strokeStyle = 'rgba(140, 180, 220, 0.6)';
			ctx.lineWidth = 0.5;

			for (let y = 0; y <= canvas.height; y += smallGrid) {
				ctx.beginPath();
				ctx.moveTo(0, y);
				ctx.lineTo(canvas.width, y);
				ctx.stroke();
			}

			// Vertical lines - same blue
			ctx.strokeStyle = 'rgba(140, 180, 220, 0.5)';
			for (let x = 0; x <= canvas.width; x += smallGrid) {
				ctx.beginPath();
				ctx.moveTo(x, 0);
				ctx.lineTo(x, canvas.height);
				ctx.stroke();
			}
		}

		// Draw placement preview
		function drawPlacementPreview() {
			if (mouseX <= 0 || mouseY <= 0) return;

			const canPlace = canPlaceTowerAt(mouseX, mouseY) && gold >= towerTypes[selectedTower].cost;
			const cellCount = towerTypes[selectedTower].cells;
			const cellSize = 14;
			const spacing = cellSize + 2;
			const totalWidth = cellCount * cellSize + (cellCount - 1) * 2;
			const startX = mouseX - totalWidth / 2 + cellSize / 2;
			const color = '#cc2222';

			if (canPlace) {
				ctx.globalAlpha = 0.5;
				ctx.strokeStyle = color;
				ctx.lineWidth = 1.5;
				ctx.lineCap = 'round';
				ctx.lineJoin = 'round';

				// Draw each cell
				for (let i = 0; i < cellCount; i++) {
					const cellX = startX + i * spacing;
					const half = cellSize / 2;

					// Draw square
					ctx.beginPath();
					ctx.moveTo(cellX - half, mouseY - half);
					ctx.lineTo(cellX + half, mouseY - half);
					ctx.lineTo(cellX + half, mouseY + half);
					ctx.lineTo(cellX - half, mouseY + half);
					ctx.closePath();
					ctx.stroke();

					// Draw X inside
					const inset = 2;
					ctx.beginPath();
					ctx.moveTo(cellX - half + inset, mouseY - half + inset);
					ctx.lineTo(cellX + half - inset, mouseY + half - inset);
					ctx.stroke();

					ctx.beginPath();
					ctx.moveTo(cellX + half - inset, mouseY - half + inset);
					ctx.lineTo(cellX - half + inset, mouseY + half - inset);
					ctx.stroke();
				}

				// Preview range
				ctx.beginPath();
				ctx.arc(mouseX, mouseY, towerTypes[selectedTower].range, 0, Math.PI * 2);
				ctx.strokeStyle = 'rgba(204, 34, 34, 0.4)';
				ctx.lineWidth = 1;
				ctx.setLineDash([5, 5]);
				ctx.stroke();
				ctx.setLineDash([]);
				ctx.globalAlpha = 1;
			} else {
				// Invalid placement - small red X
				ctx.globalAlpha = 0.5;
				ctx.strokeStyle = '#c23a3a';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(mouseX - 8, mouseY - 8);
				ctx.lineTo(mouseX + 8, mouseY + 8);
				ctx.moveTo(mouseX + 8, mouseY - 8);
				ctx.lineTo(mouseX - 8, mouseY + 8);
				ctx.stroke();
				ctx.globalAlpha = 1;
			}
		}

		// Spawn wave
		let spawnIntervalId = null;

		function spawnWave() {
			if (waveInProgress || gameOver) return;

			wave++;
			waveInProgress = true;
			updateUI();

			const enemyCount = 6 + wave * 3;
			let spawned = 0;

			spawnIntervalId = setInterval(() => {
				if (isPaused) return; // Skip spawning while paused

				if (spawned >= enemyCount || gameOver) {
					clearInterval(spawnIntervalId);
					spawnIntervalId = null;
					return;
				}

				// Determine enemy type based on wave
				let type = 'basic';
				const rand = Math.random();

				if (wave >= 2 && rand < 0.35) type = 'fast';
				if (wave >= 3 && rand < 0.25) type = 'tank';
				if (wave >= 5 && rand < 0.15 && spawned === enemyCount - 1) type = 'boss';

				// Wave scaling - enemies get stronger every 10 waves
				const enemy = new Enemy(type);
				const tier = Math.floor((wave - 1) / 10);   // 0 for waves 1-10, 1 for 11-20, etc.
				enemy.hp *= 1 + tier * 0.15;                // +15% HP every 10 waves
				enemy.maxHp = enemy.hp;
				enemy.reward = Math.floor(enemy.reward * (1 + tier * 0.05)); // +5% reward every 10 waves

				enemies.push(enemy);
				spawned++;
			}, 800 - Math.min(wave * 30, 500));
		}

		// Check wave complete
		function checkWaveComplete() {
			if (waveInProgress && enemies.length === 0) {
				waveInProgress = false;
				gold += 15 + wave * 3; // Wave completion bonus
				updateUI();
			}
		}

		// Update UI
		function updateUI() {
			document.getElementById('gold').textContent = gold;
			document.getElementById('lives').textContent = lives;
			document.getElementById('wave').textContent = wave;
			document.getElementById('score').textContent = score;
		}

		// End game
		function endGame() {
			gameOver = true;
			document.getElementById('finalScore').textContent = score;
			document.getElementById('gameOver').classList.add('show');
		}

		// Check if position is too close to path
		function isTooCloseToPath(x, y, minDist = 30) {
			for (let i = 0; i < path.length - 1; i++) {
				const start = path[i];
				const end = path[i + 1];

				// Distance from point to line segment
				const dx = end.x - start.x;
				const dy = end.y - start.y;
				const len2 = dx * dx + dy * dy;

				let t = Math.max(0, Math.min(1, ((x - start.x) * dx + (y - start.y) * dy) / len2));
				const nearX = start.x + t * dx;
				const nearY = start.y + t * dy;

				const dist = Math.hypot(x - nearX, y - nearY);
				if (dist < minDist) return true;
			}
			return false;
		}

		// Check if position is too close to another tower
		function isTooCloseToTower(x, y, minDist = 20) {
			for (const tower of towers) {
				const dist = Math.hypot(x - tower.x, y - tower.y);
				if (dist < minDist) return true;
			}
			return false;
		}

		// Check if position is valid for tower placement
		function canPlaceTowerAt(x, y) {
			// Check bounds
			if (x < 15 || x > canvas.width - 15 || y < 15 || y > canvas.height - 15) return false;
			// Check path distance
			if (isTooCloseToPath(x, y, 32)) return false;
			// Check other towers
			if (isTooCloseToTower(x, y, 22)) return false;
			return true;
		}

		// Place tower
		function placeTower(mouseX, mouseY) {
			if (!canPlaceTowerAt(mouseX, mouseY)) return;

			const cost = towerTypes[selectedTower].cost;
			if (gold < cost) return;

			gold -= cost;

			const tower = new Tower(mouseX, mouseY, selectedTower);
			towers.push(tower);
			updateUI();
		}

		// Sell tower
		function sellTower(clickX, clickY) {
			for (let i = 0; i < towers.length; i++) {
				const tower = towers[i];
				const cellIndex = tower.getCellAtPosition(clickX, clickY);
				if (cellIndex >= 0) {
					const sellValue = tower.getSellValue();
					gold += sellValue;

					// Create sell particles
					for (let j = 0; j < 8; j++) {
						particles.push(new Particle(tower.x, tower.y, '#2a7a4a', 'death'));
					}

					towers.splice(i, 1);
					updateUI();
					return true;
				}
			}
			return false;
		}

		// Check tower click - upgrade specific cell that was clicked
		function checkTowerClick(mouseX, mouseY) {
			for (const tower of towers) {
				const cellIndex = tower.getCellAtPosition(mouseX, mouseY);
				if (cellIndex >= 0) {
					tower.upgradeCell(cellIndex);
					return true;
				}
			}
			return false;
		}

		// Mouse position for hover effects
		let mouseX = 0;
		let mouseY = 0;

		// Canvas click handler
		canvas.addEventListener('click', (e) => {
			if (gameOver || isPaused) return;

			const rect = canvas.getBoundingClientRect();
			const clickX = e.clientX - rect.left;
			const clickY = e.clientY - rect.top;

			if (sellMode) {
				if (sellTower(clickX, clickY)) {
					// Tower sold, optionally exit sell mode
					// toggleSellMode(); // uncomment to auto-exit sell mode after selling
				}
			} else {
				if (!checkTowerClick(clickX, clickY)) {
					placeTower(clickX, clickY);
				}
			}
		});

		// Canvas hover handler
		canvas.addEventListener('mousemove', (e) => {
			const rect = canvas.getBoundingClientRect();
			mouseX = e.clientX - rect.left;
			mouseY = e.clientY - rect.top;

			for (const tower of towers) {
				// Check if hovering over any cell
				const cellIndex = tower.getCellAtPosition(mouseX, mouseY);
				tower.showRange = cellIndex >= 0;
			}
		});

		canvas.addEventListener('mouseleave', () => {
			mouseGridX = -1;
			mouseGridY = -1;
		});

		// Tower selection
		document.querySelectorAll('.tower-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
				btn.classList.add('selected');
				selectedTower = btn.dataset.tower;
			});
		});

		// Control buttons
		document.getElementById('startWave').addEventListener('click', spawnWave);
		document.getElementById('pauseBtn').addEventListener('click', togglePause);
		document.getElementById('sellBtn').addEventListener('click', toggleSellMode);
		document.getElementById('restart').addEventListener('click', () => location.reload());

		// Keyboard shortcuts
		document.addEventListener('keydown', (e) => {
			const keys = { '1': 'tower1', '2': 'tower2', '3': 'tower3' };
			if (keys[e.key]) {
				document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
				document.querySelector(`[data-tower="${keys[e.key]}"]`).classList.add('selected');
				selectedTower = keys[e.key];
			}
			if (e.key === ' ') {
				e.preventDefault();
				spawnWave();
			}
			if (e.key === 'p' || e.key === 'P' || e.key === '–∑' || e.key === '–ó') {
				togglePause();
			}
			if (e.key === 'Escape') {
				if (isPaused) togglePause();
				if (sellMode) toggleSellMode();
			}
			if (e.key === 's' || e.key === 'S' || e.key === '—ã' || e.key === '–´') {
				toggleSellMode();
			}
		});

		// Game loop
		let lastTime = 0;

		function gameLoop(time) {
			if (gameOver || isPaused) return;

			// Adjust time for pauses
			const adjustedTime = time - totalPausedTime;

			ctx.fillStyle = '#ffffff';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			drawGrid();
			drawPath();
			drawCave();
			drawCastle();
			drawPlacementPreview();

			// Update and draw towers
			for (const tower of towers) {
				tower.update(adjustedTime);
				tower.draw();
			}

			// Update and filter enemies
			enemies = enemies.filter(enemy => enemy.update());
			for (const enemy of enemies) {
				enemy.draw();
			}

			// Update and filter projectiles
			projectiles = projectiles.filter(proj => proj.update());
			for (const proj of projectiles) {
				proj.draw();
			}

			// Update and filter particles
			particles = particles.filter(p => p.update());
			for (const p of particles) {
				p.draw();
			}

			checkWaveComplete();

			requestAnimationFrame(gameLoop);
		}

		// Start game
		updateUI();
		gameLoop(0);
	</script>
</body>

</html>